-- Turn off SQL output and set HTML spool with styling
SET ECHO OFF FEEDBACK OFF VERIFY OFF LINESIZE 200 PAGESIZE 1000
SET TERMOUT OFF
SET MARKUP HTML ON SPOOL ON ENTMAP OFF PREFORMAT OFF HEAD '<style>
table, th, td {border:1px solid black; border-collapse: collapse; padding:4px;}
th {background-color: #f0f0f0;}
</style>'

-- Prompt for snapshot range
ACCEPT begin_snap NUMBER PROMPT 'Enter begin SNAP_ID: '
ACCEPT end_snap   NUMBER PROMPT 'Enter end   SNAP_ID: '

-- Gather database and snapshot info into substitution variables (no screen output)
COLUMN DB_NAME    NEW_VALUE DB_NAME
COLUMN DBID       NEW_VALUE DBID
COLUMN INST_NAME  NEW_VALUE INSTANCE_NAME
COLUMN HOST_NAME  NEW_VALUE HOST_NAME
COLUMN VERSION    NEW_VALUE VERSION
COLUMN BEGIN_TIME NEW_VALUE BEGIN_TIME
COLUMN END_TIME   NEW_VALUE END_TIME
COLUMN ELAPSED_SEC NEW_VALUE ELAPSED_SEC

SET TERMOUT OFF
SELECT d.name        AS DB_NAME,
       d.dbid        AS DBID,
       i.instance_name AS INST_NAME,
       i.host_name   AS HOST_NAME,
       i.version     AS VERSION
FROM   v$database d, v$instance i;
SELECT TO_CHAR(b.snap_time, 'YYYY-MM-DD HH24:MI:SS') AS BEGIN_TIME,
       TO_CHAR(e.snap_time, 'YYYY-MM-DD HH24:MI:SS') AS END_TIME,
       ROUND((e.snap_time - b.snap_time) * 86400, 0) AS ELAPSED_SEC
FROM   perfstat.stats$snapshot b, perfstat.stats$snapshot e
WHERE  b.snap_id = &begin_snap
  AND  e.snap_id = &end_snap;
SET TERMOUT ON

-- Begin spooling output to HTML file
SPOOL awr_report_&begin_snap._&end_snap..html

PROMPT <h1>AWR-like Report for &DB_NAME</h1>
PROMPT <p><b>Database:</b> &DB_NAME (DBID: &DBID) â€“ Instance: &INSTANCE_NAME on &HOST_NAME, Oracle &VERSION</p>
PROMPT <p><b>Snapshot Interval:</b> &BEGIN_TIME to &END_TIME (Elapsed: &ELAPSED_SEC seconds)</p>

PROMPT <h2>Load Profile</h2>
REM Calculate differences for key system statistics between the snapshots
WITH diff AS (
  SELECT MAX(CASE WHEN n.name = 'redo size'            THEN e.value - b.value END) AS redo_diff,
         MAX(CASE WHEN n.name = 'session logical reads' THEN e.value - b.value END) AS logical_diff,
         MAX(CASE WHEN n.name = 'db block changes'     THEN e.value - b.value END) AS block_changes_diff,
         MAX(CASE WHEN n.name = 'physical reads'       THEN e.value - b.value END) AS phys_read_diff,
         MAX(CASE WHEN n.name = 'physical writes'      THEN e.value - b.value END) AS phys_write_diff,
         MAX(CASE WHEN n.name = 'user calls'           THEN e.value - b.value END) AS calls_diff,
         MAX(CASE WHEN n.name = 'parse count (total)'  THEN e.value - b.value END) AS parses_diff,
         MAX(CASE WHEN n.name = 'parse count (hard)'   THEN e.value - b.value END) AS hard_parses_diff,
         MAX(CASE WHEN n.name = 'sorts (memory)'       THEN e.value - b.value END) AS sort_mem_diff,
         MAX(CASE WHEN n.name = 'sorts (disk)'         THEN e.value - b.value END) AS sort_disk_diff,
         MAX(CASE WHEN n.name = 'logons cumulative'    THEN e.value - b.value END) AS logons_diff,
         MAX(CASE WHEN n.name = 'execute count'        THEN e.value - b.value END) AS execs_diff,
         MAX(CASE WHEN n.name = 'user commits'         THEN e.value - b.value END) AS commits_diff,
         MAX(CASE WHEN n.name = 'user rollbacks'       THEN e.value - b.value END) AS rollbacks_diff
  FROM   perfstat.stats$sysstat b
  JOIN   perfstat.stats$sysstat e ON e.snap_id = &end_snap AND b.snap_id = &begin_snap AND e.statistic# = b.statistic#
  JOIN   perfstat.stats$stat_name n ON n.statistic# = e.statistic#
  WHERE  n.name IN ('redo size','session logical reads','db block changes','physical reads',
                    'physical writes','user calls','parse count (total)','parse count (hard)',
                    'sorts (memory)','sorts (disk)','logons cumulative','execute count',
                    'user commits','user rollbacks')
)
SELECT * 
FROM (
  SELECT 'Redo size'        AS metric,
         TO_CHAR(NVL(redo_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00')      AS "Per Second",
         TO_CHAR(NVL(redo_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00') AS "Per Transaction"
  FROM diff
  UNION ALL
  SELECT 'Logical reads',
         TO_CHAR(NVL(logical_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(logical_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Block changes',
         TO_CHAR(NVL(block_changes_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(block_changes_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Physical reads',
         TO_CHAR(NVL(phys_read_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(phys_read_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Physical writes',
         TO_CHAR(NVL(phys_write_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(phys_write_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'User calls',
         TO_CHAR(NVL(calls_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(calls_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Parses',
         TO_CHAR(NVL(parses_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(parses_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Hard parses',
         TO_CHAR(NVL(hard_parses_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(hard_parses_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Sorts',
         TO_CHAR(NVL((sort_mem_diff+sort_disk_diff)/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL((sort_mem_diff+sort_disk_diff)/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Logons',
         TO_CHAR(NVL(logons_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(logons_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Executes',
         TO_CHAR(NVL(execs_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(execs_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Rollbacks',
         TO_CHAR(NVL(rollbacks_diff/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         TO_CHAR(NVL(rollbacks_diff/NULLIF(commits_diff+rollbacks_diff,0), NULL), 'FM999,999,999.00')
  FROM diff
  UNION ALL
  SELECT 'Transactions',
         TO_CHAR(NVL((commits_diff+rollbacks_diff)/(&ELAPSED_SEC),0), 'FM999,999,999.00'),
         NULL
  FROM diff
)
ORDER BY CASE metric WHEN 'Transactions' THEN 2 ELSE 1 END, metric;
REM The above query produces a table with columns: Metric, Per Second, Per Transaction

PROMPT <h2>Top Wait Events</h2>
PROMPT <h3>Foreground Wait Events (Top 10 by Time Waited)</h3>
WITH fg_events AS (
  SELECT a.event,
         (b.total_waits - a.total_waits)           AS waits,
         (b.time_waited_micro - a.time_waited_micro) AS time_us
  FROM   perfstat.stats$system_event a
  JOIN   perfstat.stats$system_event b ON b.snap_id = &end_snap AND a.snap_id = &begin_snap AND b.event_id = a.event_id
  WHERE  a.event NOT IN (SELECT event FROM perfstat.stats$idle_event)
    AND  NOT (
          a.event IN ('log file parallel write','DB file parallel write','DB file single write',
                      'control file parallel write','control file sequential write','log file sequential read')
          OR a.event LIKE 'ARCH %' OR a.event LIKE 'LGWR%' OR a.event LIKE 'LNS %'
          OR a.event LIKE 'RFS %'  OR a.event LIKE 'MRP %' OR a.event LIKE 'Streams %' OR a.event LIKE 'XStream %'
        )
)
SELECT event "Event",
       TO_CHAR(waits, 'FM999,999,999') "Waits",
       TO_CHAR(time_us/1000000, 'FM999,999,999.00') "Time (s)",
       TO_CHAR(NVL(time_us/1000/NULLIF(waits,0),0), 'FM999,999,999.00') "Avg Wait (ms)"
FROM (
  SELECT event, waits, time_us,
         ROW_NUMBER() OVER (ORDER BY time_us DESC) AS rn
  FROM fg_events
  WHERE waits > 0
)
WHERE rn <= 10;

PROMPT <h3>Background Wait Events (Top 10 by Time Waited)</h3>
WITH bg_events AS (
  SELECT a.event,
         (b.total_waits - a.total_waits)           AS waits,
         (b.time_waited_micro - a.time_waited_micro) AS time_us
  FROM   perfstat.stats$system_event a
  JOIN   perfstat.stats$system_event b ON b.snap_id = &end_snap AND a.snap_id = &begin_snap AND b.event_id = a.event_id
  WHERE  a.event NOT IN (SELECT event FROM perfstat.stats$idle_event)
    AND  (
          a.event IN ('log file parallel write','DB file parallel write','DB file single write',
                      'control file parallel write','control file sequential write','log file sequential read')
          OR a.event LIKE 'ARCH %' OR a.event LIKE 'LGWR%' OR a.event LIKE 'LNS %'
          OR a.event LIKE 'RFS %'  OR a.event LIKE 'MRP %'
        )
)
SELECT event "Event",
       TO_CHAR(waits, 'FM999,999,999') "Waits",
       TO_CHAR(time_us/1000000, 'FM999,999,999.00') "Time (s)",
       TO_CHAR(NVL(time_us/1000/NULLIF(waits,0),0), 'FM999,999,999.00') "Avg Wait (ms)"
FROM (
  SELECT event, waits, time_us,
         ROW_NUMBER() OVER (ORDER BY time_us DESC) AS rn
  FROM bg_events
  WHERE waits > 0
)
WHERE rn <= 10;

PROMPT <h2>Top SQL Statements</h2>
WITH sql_stats AS (
  SELECT e.sql_id,
         e.module,
         e.plan_hash_value,
         (e.elapsed_time_total  - NVL(b.elapsed_time_total, 0))  AS elap_us,
         (e.cpu_time_total      - NVL(b.cpu_time_total, 0))      AS cpu_us,
         (e.buffer_gets_total   - NVL(b.buffer_gets_total, 0))   AS buf_gets,
         (e.disk_reads_total    - NVL(b.disk_reads_total, 0))    AS phys_reads
  FROM   perfstat.stats$sql_summary e
  LEFT JOIN perfstat.stats$sql_summary b ON b.snap_id = &begin_snap AND e.snap_id = &end_snap AND e.sql_id = b.sql_id
  WHERE  e.snap_id = &end_snap
)
-- SQL ordered by Elapsed Time
PROMPT <h3>SQL Ordered by Elapsed Time</h3>
SELECT sql_id            AS "SQL ID",
       NVL(module,'(none)') AS "Module",
       plan_hash_value   AS "Plan Hash",
       TO_CHAR(elap_us/1000000, 'FM999,999,999.00') AS "Elapsed (s)"
FROM (
  SELECT sql_id, module, plan_hash_value, elap_us,
         ROW_NUMBER() OVER (ORDER BY elap_us DESC) AS rn
  FROM sql_stats
  WHERE elap_us > 0
)
WHERE rn <= 10;

-- SQL ordered by CPU Time
PROMPT <h3>SQL Ordered by CPU Time</h3>
SELECT sql_id            AS "SQL ID",
       NVL(module,'(none)') AS "Module",
       plan_hash_value   AS "Plan Hash",
       TO_CHAR(cpu_us/1000000, 'FM999,999,999.00') AS "CPU Time (s)"
FROM (
  SELECT sql_id, module, plan_hash_value, cpu_us,
         ROW_NUMBER() OVER (ORDER BY cpu_us DESC) AS rn
  FROM sql_stats
  WHERE cpu_us > 0
)
WHERE rn <= 10;

-- SQL ordered by Buffer Gets
PROMPT <h3>SQL Ordered by Buffer Gets</h3>
SELECT sql_id            AS "SQL ID",
       NVL(module,'(none)') AS "Module",
       plan_hash_value   AS "Plan Hash",
       TO_CHAR(buf_gets, 'FM999,999,999') AS "Buffer Gets"
FROM (
  SELECT sql_id, module, plan_hash_value, buf_gets,
         ROW_NUMBER() OVER (ORDER BY buf_gets DESC) AS rn
  FROM sql_stats
  WHERE buf_gets > 0
)
WHERE rn <= 10;

-- SQL ordered by Physical Reads
PROMPT <h3>SQL Ordered by Physical Reads</h3>
SELECT sql_id            AS "SQL ID",
       NVL(module,'(none)') AS "Module",
       plan_hash_value   AS "Plan Hash",
       TO_CHAR(phys_reads, 'FM999,999,999') AS "Phys Reads"
FROM (
  SELECT sql_id, module, plan_hash_value, phys_reads,
         ROW_NUMBER() OVER (ORDER BY phys_reads DESC) AS rn
  FROM sql_stats
  WHERE phys_reads > 0
)
WHERE rn <= 10;

PROMPT <h2>Lock and Latch Contention</h2>
PROMPT <h3>Top Enqueue Wait Events (Locks)</h3>
WITH lock_events AS (
  SELECT a.event,
         (b.total_waits - a.total_waits)           AS waits,
         (b.time_waited_micro - a.time_waited_micro) AS time_us
  FROM   perfstat.stats$system_event a
  JOIN   perfstat.stats$system_event b ON b.snap_id = &end_snap AND a.snap_id = &begin_snap AND b.event_id = a.event_id
  WHERE  a.event NOT IN (SELECT event FROM perfstat.stats$idle_event)
    AND  (a.event LIKE 'enq:%' OR a.event LIKE 'DFS lock%' OR a.event IN ('library cache lock','library cache pin','row cache lock'))
)
SELECT event "Event",
       TO_CHAR(waits, 'FM999,999,999') "Waits",
       TO_CHAR(time_us/1000000, 'FM999,999,999.00') "Time (s)",
       TO_CHAR(NVL(time_us/1000/NULLIF(waits,0),0), 'FM999,999,999.00') "Avg Wait (ms)"
FROM (
  SELECT event, waits, time_us,
         ROW_NUMBER() OVER (ORDER BY time_us DESC) AS rn
  FROM lock_events
  WHERE waits > 0
)
WHERE rn <= 5;

PROMPT <h3>Segments with Highest Row Lock Waits</h3>
WITH seg_lock AS (
  SELECT o.owner, o.object_name, o.subobject_name,
         (e.row_lock_waits - b.row_lock_waits) AS waits
  FROM   perfstat.stats$seg_stat b
  JOIN   perfstat.stats$seg_stat e ON e.snap_id = &end_snap AND b.snap_id = &begin_snap
       AND e.obj# = b.obj# AND e.dataobj# = b.dataobj# AND e.ts# = b.ts#
  JOIN   perfstat.stats$seg_stat_obj o ON o.obj# = e.obj# AND o.dataobj# = e.dataobj# AND o.ts# = e.ts#
  WHERE  e.row_lock_waits > b.row_lock_waits
)
SELECT (owner||'.'||object_name||NVL(':'||subobject_name,'')) AS "Segment",
       TO_CHAR(waits, 'FM999,999,999') AS "Row Lock Waits"
FROM (
  SELECT owner, object_name, subobject_name, waits,
         ROW_NUMBER() OVER (ORDER BY waits DESC) AS rn
  FROM seg_lock
)
WHERE rn <= 5;

PROMPT <h3>Latch Contention (Top 5 Latches by Sleeps)</h3>
WITH latch_diff AS (
  SELECT e.name AS latch_name,
         (e.gets   - b.gets)   AS gets,
         (e.misses - b.misses) AS misses,
         (e.sleeps - b.sleeps) AS sleeps,
         (e.wait_time - b.wait_time) AS wait_cs
  FROM   perfstat.stats$latch b
  JOIN   perfstat.stats$latch e ON e.snap_id = &end_snap AND b.snap_id = &begin_snap 
       AND e.latch# = b.latch# AND e.name = b.name
)
SELECT latch_name       AS "Latch Name",
       TO_CHAR(gets,   'FM999,999,999') AS "Gets",
       TO_CHAR(misses, 'FM999,999,999') AS "Misses",
       TO_CHAR(sleeps, 'FM999,999,999') AS "Sleeps",
       TO_CHAR(wait_cs/100, 'FM999,999,999.00') AS "Wait Time (s)"
FROM (
  SELECT latch_name, gets, misses, sleeps, wait_cs,
         ROW_NUMBER() OVER (ORDER BY sleeps DESC) AS rn
  FROM latch_diff
  WHERE sleeps > 0
)
WHERE rn <= 5;

PROMPT <h2>Memory Advisory</h2>
PROMPT <h3>Buffer Cache Advisory (Default Pool)</h3>
SELECT TO_CHAR(size_for_estimate,'99999')    AS "Cache Size (MB)",
       TO_CHAR(estd_physical_reads,'999,999,999') AS "Est. Phys Reads",
       TO_CHAR(estd_physical_read_factor,'990.00') AS "Phys Read Factor",
       CASE WHEN size_factor = 1 THEN '*' ELSE '' END AS "Current?"
FROM   v$db_cache_advice
WHERE  name='DEFAULT'
  AND  block_size = (SELECT value FROM v$parameter WHERE name = 'db_block_size')
  AND  advice_status = 'ON'
ORDER BY size_for_estimate;

PROMPT <h3>SGA Target Advisory</h3>
SELECT TO_CHAR(sga_size,'99999')        AS "SGA Size (MB)",
       TO_CHAR(estd_db_time,'999,999,999')    AS "Est. DB Time",
       TO_CHAR(estd_db_time_factor,'990.000') AS "DB Time Factor",
       TO_CHAR(estd_physical_reads,'999,999,999') AS "Est. Phys Reads"
FROM   v$sga_target_advice
ORDER BY sga_size;

PROMPT <h3>PGA Target Advisory</h3>
SELECT ROUND(pga_target_for_estimate/1048576) AS "PGA Target (MB)",
       TO_CHAR(estd_pga_cache_hit_percentage, '990') AS "CacheHit (%)",
       estd_overalloc_count             AS "Over-Alloc Count"
FROM   v$pga_target_advice
ORDER BY pga_target_factor;

PROMPT <h2>Hot Objects (Segments)</h2>
PROMPT <h3>Top Segments by Logical Reads</h3>
WITH seg_log AS (
  SELECT o.owner, o.object_name, o.subobject_name,
         (e.logical_reads - b.logical_reads) AS lreads
  FROM   perfstat.stats$seg_stat b
  JOIN   perfstat.stats$seg_stat e ON e.snap_id = &end_snap AND b.snap_id = &begin_snap
       AND e.obj# = b.obj# AND e.dataobj# = b.dataobj# AND e.ts# = b.ts#
  JOIN   perfstat.stats$seg_stat_obj o ON o.obj# = e.obj# AND o.dataobj# = e.dataobj# AND o.ts# = e.ts#
  WHERE  e.logical_reads > b.logical_reads
)
SELECT (owner||'.'||object_name||NVL(':'||subobject_name,'')) AS "Segment",
       TO_CHAR(lreads, 'FM999,999,999') AS "Logical Reads"
FROM (
  SELECT owner, object_name, subobject_name, lreads,
         ROW_NUMBER() OVER (ORDER BY lreads DESC) AS rn
  FROM seg_log
)
WHERE rn <= 10;

PROMPT <h3>Top Segments by Physical Reads</h3>
WITH seg_phys AS (
  SELECT o.owner, o.object_name, o.subobject_name,
         ((e.physical_reads + e.physical_reads_direct) - (b.physical_reads + b.physical_reads_direct)) AS preads
  FROM   perfstat.stats$seg_stat b
  JOIN   perfstat.stats$seg_stat e ON e.snap_id = &end_snap AND b.snap_id = &begin_snap
       AND e.obj# = b.obj# AND e.dataobj# = b.dataobj# AND e.ts# = b.ts#
  JOIN   perfstat.stats$seg_stat_obj o ON o.obj# = e.obj# AND o.dataobj# = e.dataobj# AND o.ts# = e.ts#
  WHERE  (e.physical_reads + e.physical_reads_direct) > (b.physical_reads + b.physical_reads_direct)
)
SELECT (owner||'.'||object_name||NVL(':'||subobject_name,'')) AS "Segment",
       TO_CHAR(preads, 'FM999,999,999') AS "Physical Reads"
FROM (
  SELECT owner, object_name, subobject_name, preads,
         ROW_NUMBER() OVER (ORDER BY preads DESC) AS rn
  FROM seg_phys
)
WHERE rn <= 10;

PROMPT <h2>GoldenGate & Data Guard Wait Events</h2>
PROMPT <h3>Data Guard Related Wait Events</h3>
WITH dg_events AS (
  SELECT a.event,
         (b.total_waits - a.total_waits)           AS waits,
         (b.time_waited_micro - a.time_waited_micro) AS time_us
  FROM   perfstat.stats$system_event a
  JOIN   perfstat.stats$system_event b ON b.snap_id = &end_snap AND a.snap_id = &begin_snap AND b.event_id = a.event_id
  WHERE  a.event NOT IN (SELECT event FROM perfstat.stats$idle_event)
    AND  (a.event LIKE 'RFS%' OR a.event LIKE 'LNS%' OR a.event LIKE 'MRP%' OR a.event LIKE 'LGWR%LNS%' OR a.event LIKE 'FAL %' OR a.event LIKE 'Data Guard%')
)
SELECT "Event", "Waits", "Time (s)", "Avg Wait (ms)"
FROM (
  SELECT event AS "Event",
         TO_CHAR(waits, 'FM999,999,999') AS "Waits",
         TO_CHAR(time_us/1000000, 'FM999,999,999.00') AS "Time (s)",
         TO_CHAR(NVL(time_us/1000/NULLIF(waits,0), NULL), 'FM999,999,999.00') AS "Avg Wait (ms)",
         ROW_NUMBER() OVER (ORDER BY time_us DESC) AS rn
  FROM dg_events
  WHERE waits > 0
)
WHERE rn <= 5
UNION ALL
SELECT '(None found)', '-', '-', '-'
FROM dual
WHERE NOT EXISTS (SELECT 1 FROM dg_events WHERE waits > 0);

PROMPT <h3>GoldenGate Related Wait Events</h3>
WITH gg_events AS (
  SELECT a.event,
         (b.total_waits - a.total_waits)           AS waits,
         (b.time_waited_micro - a.time_waited_micro) AS time_us
  FROM   perfstat.stats$system_event a
  JOIN   perfstat.stats$system_event b ON b.snap_id = &end_snap AND a.snap_id = &begin_snap AND b.event_id = a.event_id
  WHERE  a.event NOT IN (SELECT event FROM perfstat.stats$idle_event)
    AND  (a.event LIKE 'Streams%' OR a.event LIKE 'XStream%')
)
SELECT "Event", "Waits", "Time (s)", "Avg Wait (ms)"
FROM (
  SELECT event AS "Event",
         TO_CHAR(waits, 'FM999,999,999') AS "Waits",
         TO_CHAR(time_us/1000000, 'FM999,999,999.00') AS "Time (s)",
         TO_CHAR(NVL(time_us/1000/NULLIF(waits,0), NULL), 'FM999,999,999.00') AS "Avg Wait (ms)",
         ROW_NUMBER() OVER (ORDER BY time_us DESC) AS rn
  FROM gg_events
  WHERE waits > 0
)
WHERE rn <= 5
UNION ALL
SELECT '(None found)', '-', '-', '-'
FROM dual
WHERE NOT EXISTS (SELECT 1 FROM gg_events WHERE waits > 0);

-- Finish HTML spool
SPOOL OFF
SET MARKUP HTML OFF
SET TERMOUT ON
PROMPT Report generated to awr_report_&begin_snap._&end_snap..html
